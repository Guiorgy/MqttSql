using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
#if LOGGEREXTENSIONSGENERATORDEBUG
using System.Diagnostics;
#endif
using System.Linq;
using System.Text;

namespace SourceGenerators;

[Generator(LanguageNames.CSharp)]
internal sealed partial class LoggerExtensionsSourceGenerator : IIncrementalGenerator
{
    private const string Tab = "    ";
    private static readonly int AppendLineLength = new StringBuilder().AppendLine().Length;

    /*
     * 0: namespace
     * 1: class/interface modifiers
     * 2: class/interface keyword
     * 3: class/interface name
     * 4: class/interface contents (each line prefixed with a tab)
     */
    private const string ClassFormat = """
        // <auto-generated/>
        #nullable enable
        
        using System;
        using static {0}.Logger;
        
        namespace {0};
        
        {1} {2} {3}
        {{
        {4}
        }}
        """;

    /*
     * 0: tab
     * 1: log level
     */
    private const string ExtensionMethodFromat = """
        {0}// public static void {1}(this Logger logger, params string[] messageBits) => logger.Log(LogLevel.{1}, messageBits);
        {0}public static void {1}(this Logger logger, params object?[]? messageBits) => logger.Log(LogLevel.{1}, messageBits);
        {0}// public static void {1}(this Logger logger, Exception exception, params string[] messageBits) => logger.Log(LogLevel.{1}, exception, messageBits);
        {0}public static void {1}(this Logger logger, Exception exception, params object?[]? messageBits) => logger.Log(LogLevel.{1}, exception, messageBits);
        {0}public static void {1}(this Logger logger, Exception exception) => logger.Log(LogLevel.{1}, exception);
        """;

    /*
     * 0: tab
     * 1: log level
     * 2: generic parameters
     * 3: method parameters
     * 4: comma separated
     */
    private const string GenericExtensionMethodFormat = """
        {0}public static void {1}<{2}>(this Logger logger, {3}) {{
        {0}{0}if (!logger.EnabledFor(LogLevel.{1})) return;
        {0}{0}logger.Log(LogLevel.{1}, new object?[] {{ {4} }});
        {0}}}
        {0}public static void {1}<{2}>(this Logger logger, Exception exception, {3}) {{
        {0}{0}if (!logger.EnabledFor(LogLevel.{1})) return;
        {0}{0}logger.Log(LogLevel.{1}, exception, new object?[] {{ {4} }});
        {0}}}
        """;

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassOrInterfaceAttributeSyntaxProvider.Capture?> captures)
    {
#if LOGGEREXTENSIONSGENERATORDEBUG
        if (!Debugger.IsAttached) Debugger.Launch();
#endif

        if (captures.IsDefaultOrEmpty) return;

        var distinctCaptures = captures.Distinct().Select(capture => capture!.Value);

        foreach (var capture in distinctCaptures)
        {
            var semanticModel = compilation.GetSemanticModel(capture.ClassDeclaration?.SyntaxTree ?? capture.InterfaceDeclaration!.SyntaxTree);
            (var genericOverrideCount, var logLevels) = GetAttributeArguments(semanticModel, capture.AttributeDeclaration);

            var avgLogLevelLength = logLevels.Average(logLevel => logLevel.Length).Ceiling();
            var methodSources = new StringBuilder((
                ExtensionMethodFromat.Length + (5 * Tab.Length) + (10 * avgLogLevelLength)
                + ((GenericExtensionMethodFormat.Length + (6 * Tab.Length) + (3 * avgLogLevelLength) + (("T**, ".Length + "messageBit**, ".Length) * genericOverrideCount)) * genericOverrideCount)
            ) * logLevels.Length);

            foreach (var logLevel in logLevels)
            {
                methodSources.AppendFormat(ExtensionMethodFromat, Tab, logLevel).AppendLine();
            }

            if (genericOverrideCount != 0)
            {
                var genericParameters = new StringBuilder(
                    (", ".Length * (genericOverrideCount - 1))
                    + ("T**".Length * genericOverrideCount)
                );
                var methodParameters = new StringBuilder(
                    (", ".Length * (genericOverrideCount - 1))
                    + (("T**".Length + " messageBit**".Length) * genericOverrideCount)
                );
                var newArrayValues = new StringBuilder(
                    (", ".Length * (genericOverrideCount - 1))
                    + ("messageBit**".Length * genericOverrideCount)
                );

                for (int i = 0; i < genericOverrideCount; i++)
                {
                    if (i != 0)
                    {
                        genericParameters.Append(", ");
                        methodParameters.Append(", ");
                        newArrayValues.Append(", ");
                    }

                    genericParameters.Append('T').Append(i);
                    methodParameters.Append('T').Append(i).Append(" messageBit").Append(i);
                    newArrayValues.Append("messageBit").Append(i);

                    foreach (var logLevel in logLevels)
                    {
                        methodSources.AppendFormat(GenericExtensionMethodFormat, Tab, logLevel, genericParameters, methodParameters, newArrayValues).AppendLine();
                    }
                }
            }

            methodSources.Length -= AppendLineLength; // undo last .AppendLine()

            var source = string.Format(ClassFormat, capture.Namespace, capture.Modifiers, capture.Keyword, capture.Name, methodSources.ToString());

            context.AddSource($"{capture.Name}.generated.cs", source);
        }
    }

    private static (int GenericOverrideCount, string[] LogLevels) GetAttributeArguments(SemanticModel semanticModel, AttributeSyntax attribute)
    {
        if (attribute.ArgumentList!.Arguments.Count < 2) throw new LoggerExtensionsSourceGeneratorException("Missing arguments");

        var genericOverrideCountArgument = attribute.ArgumentList!.Arguments[0];
        var genericOverrideCountExpression = genericOverrideCountArgument.Expression;
        var genericOverrideCountOptional = semanticModel.GetConstantValue(genericOverrideCountExpression);
        if (!genericOverrideCountOptional.HasValue || genericOverrideCountOptional.Value == null) throw new LoggerExtensionsSourceGeneratorException("Failed to parse 'genericOverrideCount' argument");
        var genericOverrideCount = (int)genericOverrideCountOptional.Value;

        var logLevels = new List<string>(attribute.ArgumentList.Arguments.Count - 1);

        for (int i = 0; i < logLevels.Capacity; i++)
        {
            var logLevelsArgument = attribute.ArgumentList!.Arguments[1 + i];
            var logLevelsExpression = logLevelsArgument.Expression;
            var logLevelsOptional = semanticModel.GetConstantValue(logLevelsExpression);
            if (!logLevelsOptional.HasValue || logLevelsOptional.Value == null) throw new LoggerExtensionsSourceGeneratorException("Failed to parse 'logLevels' argument");
            var logLevel = logLevelsOptional.Value.ToString();

            logLevels.Add(logLevel);
        }

        return (genericOverrideCount, logLevels.ToArray());
    }

    private static readonly ClassOrInterfaceAttributeSyntaxProvider syntaxProvider = new("LoggerExtensionsAttribute", "LoggerExtensions");

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var captures = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: syntaxProvider.Predicate,
            transform: syntaxProvider.Transform
        ).Where(static capture => capture is not null);

        var compilationAndCaptures = context.CompilationProvider.Combine(captures.Collect());

        context.RegisterSourceOutput(compilationAndCaptures, static (context, source) => Execute(context, source.Left, source.Right));
    }
}
