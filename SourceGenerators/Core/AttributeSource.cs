/*
    This file is part of MqttSql (Copyright © 2024  Guiorgy).
    MqttSql is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
    MqttSql is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
    You should have received a copy of the GNU General Public License along with Foobar. If not, see <https://www.gnu.org/licenses/>.
*/

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SourceGenerators;

internal sealed class AttributeSource<T> where T : IIncrementalGenerator
{
    public string AttributeName { get; }
    public string AttributeFullName { get; }
    public string AttributeFileName { get; }
    public string AttributeSourceCode { get; }

    public AttributeSource(string attributeName, AttributeTargets validOn, bool allowMultiple, bool inherited, string attributeSourceCode = "")
    {
        AttributeName = attributeName;

        var generatorType = typeof(T);
        var @namespace = generatorType.Namespace;
        var assemblyName = generatorType.Assembly.GetName();
        var generatedCodeAttribute = $@"global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assemblyName.Name}"", ""{assemblyName.Version}"")";

        AttributeFullName = $"{@namespace}.{attributeName}";
        AttributeFileName = $"{attributeName}.generated.cs";

        var attributeTargets = string.Join(" | ", SeparateFlags(validOn).Select(target => $"global::System.AttributeTargets.{target}"));
        AttributeSourceCode = $$"""
            // <auto-generated/>
            #nullable enable

            namespace {{@namespace}}
            {
                [{{generatedCodeAttribute}}]
                [global::System.AttributeUsage(validOn: {{attributeTargets}}, AllowMultiple = {{ToSourceString(allowMultiple)}}, Inherited = {{ToSourceString(inherited)}})]
                sealed class {{attributeName}} : global::System.Attribute
                {
            {{NormalizeIndentation(attributeSourceCode, 2)}}
                }
            }
            """;
    }

    private AttributeSource(string attributeName, (AttributeTargets validOn, bool allowMultiple, bool inherited) deconstructed, string attributeSourceCode = "") : this(attributeName, deconstructed.validOn, deconstructed.allowMultiple, deconstructed.inherited, attributeSourceCode)
    {
    }

    public AttributeSource(string attributeName, AttributeUsageAttribute? attributeUsage = null, string attributeSourceCode = "") : this(attributeName, Deconstruct(attributeUsage), attributeSourceCode)
    {
    }

    public AttributeSource(string attributeName, string attributeSourceCode) : this(attributeName, null, attributeSourceCode)
    {
    }

    private static (AttributeTargets validOn, bool allowMultiple, bool inherited) Deconstruct(AttributeUsageAttribute? attributeUsage) =>
        attributeUsage != null
            ? (attributeUsage.ValidOn, attributeUsage.AllowMultiple, attributeUsage.Inherited)
            : (AttributeTargets.All, false, true);

    private static class AttributeTargetValues
    {
        private static bool IsPowerOfTwo(int value) => value != 0 && (value & (value - 1)) == 0;
        public static readonly int[] FlagValues = Enum.GetValues(typeof(AttributeTargets)).Cast<int>().Where(IsPowerOfTwo).ToArray();
    }

    private static IEnumerable<AttributeTargets> SeparateFlags(AttributeTargets targets)
    {
        if (targets == AttributeTargets.All) return [AttributeTargets.All];

        int targetsValue = (int)targets;
        return AttributeTargetValues.FlagValues.Where(value => (value & targetsValue) == value).Cast<AttributeTargets>();
    }

    private static string ToSourceString(bool value) => value ? "true" : "false";

    private static string NormalizeIndentation(string text, int levels, string indentation = "    ")
    {
        indentation = string.Concat(Enumerable.Repeat(indentation, levels));

        return indentation + text.Replace("\r\n", "\n").Replace("\n", $"\n{indentation}");
    }

    public void EmitSourceCode(IncrementalGeneratorPostInitializationContext context) =>
        context.AddSource(AttributeFileName, SourceText.From(AttributeSourceCode, Encoding.UTF8));
}

internal static class AttributeSourceExtensions
{
    public static void EmitAttribute<T>(this IncrementalGeneratorInitializationContext context, AttributeSource<T> attributeSource) where T : IIncrementalGenerator
        => context.RegisterPostInitializationOutput(attributeSource.EmitSourceCode);
}
